---
id: 646
title: NHibernate Fetch strategies
date: 2014-07-04T07:40:00+00:00
author: raffaeu
layout: post
guid: http://blog.raffaeu.com/?p=646
permalink: /archive/:year/:month/:day/:title/
categories:
  - 'C#'
  - NHibernate
---
In this blog post I want to illustrate how we can eager load child and parent objects inside memory using NHibernate and how to avoid the nasty problem of creating **Cartesian products**. I will show you how this can be achieved using the three different type of Query pattern implemented inside NHibernate. 

For this example I am using the version 3.3 of NHibernate against a SQLite database to have some quick “in memory” tests.

## The Domain Model

My model is quite straighforward, is composed by a **Person** entity and two child collections, **Address** and **Phone**, like illustrated in the following picture:

[<img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="http://blog.raffaeu.com/wp-content/uploads/NHibernate-Fetch-strategies_6DF6/image_thumb.png" width="420" height="219" />](http://blog.raffaeu.com/wp-content/uploads/NHibernate-Fetch-strategies_6DF6/image.png)

For the Id I am using a **System.Guid** data type, for the collections I am using an **IList<T>** and the mapping is achieved using **<Bag>** with the **inverse=”true”** attribute. I don’t write the remaining mapping for simplicity.

<pre class="csharpcode"><span class="kwrd">&lt;</span><span class="html">class</span> <span class="attr">name</span><span class="kwrd">="Person"</span> <span class="attr">abstract</span><span class="kwrd">="false"</span> <span class="attr">table</span><span class="kwrd">="Person"</span><span class="kwrd">&gt;</span>
  <span class="kwrd">&lt;</span><span class="html">id</span> <span class="attr">name</span><span class="kwrd">="Id"</span><span class="kwrd">&gt;</span>
    <span class="kwrd">&lt;</span><span class="html">generator</span> <span class="attr">class</span><span class="kwrd">="guid.comb"</span> <span class="kwrd">/&gt;</span>
  <span class="kwrd">&lt;/</span><span class="html">id</span><span class="kwrd">&gt;</span>

  <span class="kwrd">&lt;</span><span class="html">property</span> <span class="attr">name</span><span class="kwrd">="FirstName"</span> <span class="kwrd">/&gt;</span>
  <span class="kwrd">&lt;</span><span class="html">property</span> <span class="attr">name</span><span class="kwrd">="LastName"</span> <span class="kwrd">/&gt;</span>

  <span class="kwrd">&lt;</span><span class="html">bag</span> <span class="attr">name</span><span class="kwrd">="Addresses"</span> <span class="attr">inverse</span><span class="kwrd">="true"</span> <span class="attr">table</span><span class="kwrd">="Address"</span> <span class="attr">cascade</span><span class="kwrd">="all"</span><span class="kwrd">&gt;</span>
    <span class="kwrd">&lt;</span><span class="html">key</span> <span class="attr">column</span><span class="kwrd">="PersonId"</span> <span class="kwrd">/&gt;</span>
    <span class="kwrd">&lt;</span><span class="html">one-to-many</span> <span class="attr">class</span><span class="kwrd">="Address"</span><span class="kwrd">/&gt;</span>
  <span class="kwrd">&lt;/</span><span class="html">bag</span><span class="kwrd">&gt;</span>

  <span class="kwrd">&lt;</span><span class="html">bag</span> <span class="attr">name</span><span class="kwrd">="Phones"</span> <span class="attr">inverse</span><span class="kwrd">="true"</span> <span class="attr">table</span><span class="kwrd">="Phone"</span> <span class="attr">cascade</span><span class="kwrd">="all"</span><span class="kwrd">&gt;</span>
    <span class="kwrd">&lt;</span><span class="html">key</span> <span class="attr">column</span><span class="kwrd">="PersonId"</span> <span class="kwrd">/&gt;</span>
    <span class="kwrd">&lt;</span><span class="html">one-to-many</span> <span class="attr">class</span><span class="kwrd">="Phone"</span><span class="kwrd">/&gt;</span>
  <span class="kwrd">&lt;/</span><span class="html">bag</span><span class="kwrd">&gt;</span>
<span class="kwrd">&lt;/</span><span class="html">class</span><span class="kwrd">&gt;</span></pre>

## NHibernate Linq</h2> 

With the Linq extension for NHibernate, I can easily eager load the two child collections using the following syntax:

<pre class="csharpcode">Person expectedPerson = session.Query&lt;Person&gt;()
    .FetchMany(p =&gt; p.Phones)
        .ThenFetch(p =&gt; p.PhoneType)
    .FetchMany(p =&gt; p.Addresses)
    .Where(x =&gt; x.Id == person.Id)
    .ToList().First();</pre>

The problem of this query is that I will receive a nasty Cartesian product. Why? Well let’s have a look at the SQL generated by this Linq using NHibernate&#160; profiler:

[<img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="http://blog.raffaeu.com/wp-content/uploads/NHibernate-Fetch-strategies_6DF6/image_thumb_3.png" width="420" height="120" />](http://blog.raffaeu.com/wp-content/uploads/NHibernate-Fetch-strategies_6DF6/image_3.png)

In my case I have 2 Phone records and 1 Address record that belong to the parent Person. If I have a look at the statistics I can see that the total number of rows is wrong:

[<img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="http://blog.raffaeu.com/wp-content/uploads/NHibernate-Fetch-strategies_6DF6/image_thumb_4.png" width="260" height="126" />](http://blog.raffaeu.com/wp-content/uploads/NHibernate-Fetch-strategies_6DF6/image_4.png)

Unfortunately, if I write the following test, it passes, which means that my Root Aggregate entity is wrongly loaded:

<pre class="csharpcode"><span class="rem">// wrong because address is only 1</span>
expectedPerson.Addresses
   .Count.Should().Be(2, <span class="str">"There is only one address"</span>);
expectedPerson.Phones
   .Count.Should().Be(2, <span class="str">"There are two phones"</span>);</pre>

The solution is to batch the collections into two different query, without affecting too much the Database performances. In order to achieve this goal I have to use the **Future** syntax and tell to NHibernate to build a Root Aggregate with three database batch calls:

<pre class="csharpcode"><span class="rem">// create the first query</span>
var query = session.Query&lt;Person&gt;()
      .Where(x =&gt; x.Id == person.Id);
<span class="rem">// batch the collections</span>
query
   .FetchMany(x =&gt; x.Addresses)
   .ToFuture();
query
   .FetchMany(x =&gt; x.Phones)
   .ThenFetch(p =&gt; p.PhoneType)
   .ToFuture();
<span class="rem">// execute the queries in one roundtrip</span>
Person expectedPerson = query.ToFuture().ToList().First();</pre>

Now if I profile my query, I can see that the entities loaded are loaded using 3 SQL queries but batched together into one single database call:

[<img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="http://blog.raffaeu.com/wp-content/uploads/NHibernate-Fetch-strategies_6DF6/image_thumb_5.png" width="420" height="78" />](http://blog.raffaeu.com/wp-content/uploads/NHibernate-Fetch-strategies_6DF6/image_5.png)

Regarding the performances, this is the difference between a Cartesian product and a Batch call:

[<img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="http://blog.raffaeu.com/wp-content/uploads/NHibernate-Fetch-strategies_6DF6/image_thumb_6.png" width="420" height="137" />](http://blog.raffaeu.com/wp-content/uploads/NHibernate-Fetch-strategies_6DF6/image_6.png)

## NHibernate QueryOver

The same mechanism is available also for the QueryOver<T> component, we can instruct NHibernate to create a left outer join, and get a Cartesian product, like the following statement:

<pre class="csharpcode">Phone phone = <span class="kwrd">null</span>;
PhoneType phoneType = <span class="kwrd">null</span>;
<span class="rem">// One query</span>
Person expectedPerson = session.QueryOver&lt;Person&gt;()
    <span class="rem">// Inner Join</span>
    .Fetch(p =&gt; p.Addresses).Eager
    <span class="rem">// left outer join</span>
    .Left.JoinAlias(p =&gt; p.Phones, () =&gt; phone)
    .Left.JoinAlias(() =&gt; phone.PhoneType, () =&gt; phoneType)
    .Where(x =&gt; x.Id == person.Id)
    .TransformUsing(Transformers.DistinctRootEntity)
    .List().First();</pre>

As you can see here I am trying to apply the transformer **DistinctRootEntity**, but unfortunately the transformer **does not work** if you eager load more than 1 child collection, because the Database returns more than 1 instance of the same Root Aggregate.

Also in this case, the alternative is to Batch the collections and send 3 queries to the Database in one round trip:

<pre class="csharpcode">Phone phone = <span class="kwrd">null</span>;
PhoneType phoneType = <span class="kwrd">null</span>;
<span class="rem">// prepare the query</span>
var query = session.QueryOver&lt;Person&gt;()
    .Where(x =&gt; x.Id == person.Id)
    .Future();
<span class="rem">// eager load in one batch the first collection</span>
session.QueryOver&lt;Person&gt;()
    .Fetch(x =&gt; x.Addresses).Eager
    .Future();
<span class="rem">// second collection with grandchildren</span>
session.QueryOver&lt;Person&gt;()
    .Left.JoinAlias(p =&gt; p.Phones, () =&gt; phone)
    .Left.JoinAlias(() =&gt; phone.PhoneType, () =&gt; phoneType)
    .Future();
<span class="rem">// execute the query</span>
Person expectedPerson = query.ToList().First();</pre>

Personally, the only thing that I don’t like about QueryOver<T> is the syntax, as you can see from my complex query I need to create some empty pointers to the object Phone and PhoneType. I don’t like it because when I batch 3,&#160; 4 collections I always come up with 3, 4 variables that are quite ugly and useless.

## NHibernate HQL

HQL is a great query language, it allows you to really write any kind of complex query and the biggest advantage, compared to Linq or QueryOver<T> is the fully support by the framework.

The only downside is that it requires “magic strings”, so you must be very careful on what query you write because it is very easy to write wrong queries and get a nice runtime exception.

So, also in this case, I can eager load everything in one shot, and get again a Cartesian product:

<pre class="csharpcode">Person expectedPerson =
    session.CreateQuery(<span class="str">@"
    from Person p 
    left join fetch p.Addresses a 
    left join fetch p.Phones ph 
    left join fetch ph.PhoneType pt
    where p.Id = :id"</span>)
        .SetParameter(<span class="str">"id"</span>, person.Id)
        .List&lt;Person&gt;().First();</pre>

Or batch 3 different HQL query in one Database call:

<pre class="csharpcode"><span class="rem">// prepare the query</span>
var query = session.CreateQuery(<span class="str">"from Person p where p.Id = :id"</span>)
        .SetParameter(<span class="str">"id"</span>, person.Id)
        .Future&lt;Person&gt;();
<span class="rem">// eager load first collection</span>
session.CreateQuery(<span class="str">"from Person p 
                     left join fetch p.Addresses a where p.Id = :id"</span>)
        .SetParameter(<span class="str">"id"</span>, person.Id)
        .Future&lt;Person&gt;();
<span class="rem">// eager load second collection</span>
session.CreateQuery(<span class="str">"from Person p
                     left join fetch p.Phones ph 
                     left join fetch ph.PhoneType pt where p.Id = :id"</span>)
        .SetParameter(<span class="str">"id"</span>, person.Id)
        .Future&lt;Person&gt;();</pre>

## Eager Load vs Batch</h2> 

Actually I run some tests in order to understand if the performances are better by:

  * Running an eager query and clean manually the duplicated records 
  * Run a batch set of queries and get a clean Root Aggregate

These are my results:

[<img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="http://blog.raffaeu.com/wp-content/uploads/NHibernate-Fetch-strategies_6DF6/image_thumb_7.png" width="232" height="70" />](http://blog.raffaeu.com/wp-content/uploads/NHibernate-Fetch-strategies_6DF6/image_7.png)

And surprisingly the eager load + C# cleanup is slower than the batch call. <img class="wlEmoticon wlEmoticon-smile" style="border-top-style: none; border-bottom-style: none; border-right-style: none; border-left-style: none" alt="Smile" src="http://blog.raffaeu.com/wp-content/uploads/NHibernate-Fetch-strategies_6DF6/wlEmoticon-smile.png" />